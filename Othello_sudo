
count 구조체 {
 int cnt = 4 // 전체 돌의 개수 4 <= cnt <= 64
 int blCnt = 2 // 검은돌의 개수 0 <= blCnt <= 64
 int whCnt = 2 // 흰돌의 개수 0 <= whCnt <= 64
}
int turn = 0 // 턴 시작 전
char color = '\0' // '○' or '●'
char gameBoard[10][10] // '○' or '●'
for i in range(0:10) {
 for j in range(0:10) {
 gameBoard[i][j] = '\0' // 널문자로 초기화 해놓자.
 }
}
gameBoard[4][4] = gameBoard[5][5] = '●'
gameBoard[4][5] = gameBoard[5][4] = '○'
// 게임보드 초기 상태
boolean boardEmpty[10][10] // 보드에 빈 자리가 있는지 확인
for i in range(0:10) {
 for j in range(0:10) {
 boardEmpty[i][j] = true // 널문자로 초기화 해놓자.
 }
}
boardEmpty[4][4] = boardEmpty[5][5] = boardEmpty[4][5] = boardEmpty[5][4] = false
for i in range(0:10) {
 boardEmpty[0][i] = false
 boardEmpty[9][i] = false
 boardEmpty[i][0] = false
 boardEmpty[i][9] = false
}
// 가운데 및 가장자리 4개는 비어있지 않은 것(false)으로 초기화
int gameOver(count) { // 게임이 끝났는지 확인하는 함수
 if(cnt = 64 || blCnt == 0 || WhCnt == 0)
 return 1
 else
 return 0
}
int imposBoard(gameBoard, color) // 해당하는 돌이 자리에 둘 수 있는지 확인 하는 함수
// 둘 수 없으면 스킵.
char stoneColor(turn) {
 if(turn/2 = 0) // 짝수면 검은돌
 return '●'
 else
 return '○' // 홀수면 흰돌
}
// 놓을 자리가 없어서 턴이 넘어가도 턴을 소비한 것으로 생각.
void resultPrint(count) { // 게임 결과 출력
 if(blCnt > whCnt)
 print("WINNER : BLACK!")
 elif(blCnt < whCnt)
 print("WINNER : WHITE!")
 else
 print("DRAW!)
}
boardPrint(gameBoard) { // 게임보드 출력
 for i in range(1:9) {
 print(" ")
 print(i)
 }
 // 가로 열 출력 1 2 3 4 5 6 7 8
 print("\n")
 for i in range(1:9) {
 print(i)
 // 가로 열 출력 1 2 3 4 5 6 7 8
 for j in range(1:9) {
 print(" ")
 gameBoard[i][j]
 }
 print("\n")
}
play(gameBoard, cnt, color) { // 가장 중요한 기능. 돌을 놓은 후에 색이 바뀌는 기능.
 boardPrint(gameBoard)
 print("놓을 곳을 입력하세요. 예시: 1, 2\n")
 
 print("해당 영역에는 돌을 놓을 수 없습니다.\n") // 다시 둘 수 있게 돌아가기
}
<main>
print("Othello Game\n")
화면을 통해 게임을 할 수 있는 기능 필요
while(!gameOver(count)) { // 게임 끝날 때까지 반복
 color = stoneColor(++turn) // 1턴 지남.
 if(imposBoard(gameBoard, color)){ // 해당 색의 돌이 자리에 둘 수 없으면 턴만 넘어감.
 break
 }
 play() // 실질적 기능.
}
resultPrint(count)﻿
